/*!
 * ExtActiveTabState
 * Part of the ExtHelpers project
 * @version  v1.7.2
 * @author   Gerrproger
 * @license  MIT License
 * Repo:     http://github.com/gerrproger/ext-helpers
 * Issues:   http://github.com/gerrproger/ext-helpers/issues
 */(function(r,a){"use strict";typeof module=="object"&&typeof module.exports=="object"?module.exports=a(r,document):typeof define=="function"&&define.amd?define(null,function(){a(r,document)}):r.ExtActiveTabState=a(r,document)})(typeof window<"u"?window:this,function(r,a){"use strict";class l{constructor(){return this.isBackgroundScript=!!(chrome.extension.getBackgroundPage&&chrome.extension.getBackgroundPage()===r),this.callbacksNoState=[],this.callbacks={default:[]},this.api={subscribe:this.subscribe.bind(this),unsubscribe:this.unsubscribe.bind(this)},this.isBackgroundScript?this._initBackground():this._initContent(),this.api}subscribe(e,t){return this._processSubscriptions("subscribe",t,e)}unsubscribe(e){return this._processSubscriptions("unsubscribe",e)}_processSubscriptions(e,t,c){if(e==="subscribe"&&typeof c!="function"&&this.isBackgroundScript)throw new Error("Callback should be a function!");if(t&&typeof t!="string"&&(!this.isBackgroundScript||typeof t!="boolean"))throw new Error(`Namespace should be a string${this.isBackgroundScript?" or a a boolean":""}!`);return!t&&this.isBackgroundScript?e==="subscribe"?(this.callbacksNoState.push(c),r.dispatchEvent(new CustomEvent("checkTab")),this.api):(this.callbacksNoState=[],this.api):(t=typeof t=="string"?t:"default",e==="subscribe"?(this.callbacks[t]?this.callbacks[t].push(c):this.callbacks[t]=[c],r.dispatchEvent(new CustomEvent("checkTab")),this.api):(this.callbacks[t]&&(this.callbacks[t]=[]),this.api))}_initBackground(){let e=null,t=null;const c=()=>{chrome.tabs.query({active:!0,lastFocusedWindow:!0},i=>{const s=i[0];s&&(t=s.windowId,s.id!==e&&(e=s.id,u(s)))})},o=(i,s,n)=>{s.status!=="complete"||n.windowId!==t||!n.active||u(n)},u=i=>{Object.keys(this.callbacks).forEach(s=>{d(i,s,n=>{this.callbacks[s].forEach(h=>{h.call(r,i,n)})})}),this.callbacksNoState.forEach(s=>{s.call(r,i)})},d=(i,s,n)=>{chrome.tabs.sendMessage(i.id,{extActiveTabState:{namespace:s}},h=>{if(chrome.runtime.lastError)switch(n(),chrome.runtime.lastError.message){case"Could not establish connection. Receiving end does not exist.":case"The message port closed before a response was received.":return;default:throw new Error(chrome.runtime.lastError.message)}n(h.extActiveTabState.response)})};c(),chrome.tabs.onActivated.addListener(c),chrome.windows.onFocusChanged.addListener(c),chrome.tabs.onUpdated.addListener(o),r.addEventListener("checkTab",()=>{e=null,c()}),chrome.tabs.onCreated.addListener(i=>{i.active&&(e=i.id)})}_initContent(){chrome.runtime.onMessage.addListener((e,t,c)=>{let o="default";if(!e.extActiveTabState)return;e.extActiveTabState.namespace&&(o=e.extActiveTabState.namespace);const u=this.callbacks[o]?this.callbacks[o].reduce((d,i)=>{const s=typeof i=="function"?i.call(r):i;return Object.assign(d,s)},{}):{};return c({extActiveTabState:{response:u}}),!0})}}return l});
